{"title":"Johnson King's Blog","description":"Johnson's technical blog","language":null,"link":"https://finalagito.github.io","pubDate":"Tue, 17 Jan 2017 02:17:27 GMT","lastBuildDate":"Sat, 17 Jun 2017 15:04:30 GMT","generator":"hexo-generator-json-feed","webMaster":"Johnson King","items":[{"title":"R and R*Tree(二):The Dynamic Structure For Spatial Searching","link":"https://finalagito.github.io/2017/01/17/R-and-R-Tree-二-The-Dynamic-Structure-For-Spatial-Searching/","description":"This article is not completed, I will add the demo codes to this article.Ok, after so many time, now we can finally start our second trip.Today I will introduce the rest of the algorithms, and make a comparison between the R-tree and the R* tree.Most of them are the same, but the R* tree has some important change in the algorithms.But first, let’s finish the last part of R-tree. 1.Algorithm(Undertake section in the previous article)1.1 Delete AlgorithmFirst, let’s start with a easy one, the delete algorithm.We use this function to deal with the situation that you want to delete a index (or we called it Value) E from the tree. We denoted as E.Now I will show you the steps: Use the Find Leaf Function to find the Leaf L which include the record E, end this program when the record can’t be find. Delete L from E. Use the Function Condense Tree , and pass the L as the parameter. If the Root node have only one leaf node after the condense, use the leaf node as the new root node. 1.2 Condense Tree AlgorithmUsing a node which has deleted one record as the parameter.Translating the records of the node and delete itself if the records’number has became so small.We also can delete the transport node if we have the demand. Ajusting the area of all the rectangles from root node to which node you choose. Keeping their area smallest.Steps: We transite the L to N, assume Q as the delete nodes, which equals to NULL. If N is the root node, go to the step 6, or denote P as N’s parent node, ‘EN’ as the record in N. If N’s record nodes smaller than the limit number m, delete the EN from P, and add N to Q’s room. If N hasn’t be deleted, we should adjust ENI to help it include all the records in N. Let N equals to P, loop the step from 2. Reinsert the node from Q into the tree, and you should put the nodes which at the upper layer on the tree’s upper layer. (In order to make the original child nodes become the root’s child nodes.) 1.3 Node Split AlgorithmIn order to make a best split method for control the rectangle’s area smallest. 1.4 Quadratic Cost AlgorithmIn order to find a split method to get the smallest area.Step: Find two nodes in the line(We have amount m+1 nodes) which have waste the biggest area if we put them together. (Use the area of the rectangle include with the two nodes minus each area of the two nodes) Others use the same method to divide into two groups.","pubDate":"Tue, 17 Jan 2017 02:17:27 GMT","guid":"https://finalagito.github.io/2017/01/17/R-and-R-Tree-二-The-Dynamic-Structure-For-Spatial-Searching/","category":"algorithm"},{"title":"R and R*Tree(一):The Dynamic Structure For Spatial Searching","link":"https://finalagito.github.io/2016/11/01/R-and-R-Tree-一-The-Dynamic-Structure-For-Spatial-Searching/","description":"This article is not completed, I will add the demo codes to this article. 1.Spatial SearchingBefore I start to talking about it, you may have to know something of two words: “Dimensional” and “Searching”. You always can hear a word called “Dimensional”, we used it in every aspect of life, and we always need to solve some problem about it. Straight line belongs to one dimensional space, and the plane is two dimensional and a cube is three-dimensional. And “Searching”, If you are engaged in industries related to IT then you will not be unfamiliar with it, because we have mentioned so many, many times in our work and life. Searching for the information, the food’s information, the place’s information, the people’s information, We have been searching for this all the time. So, what’s “Spatial Searching”? Now we must post a question first: If our data is not one-dimensional(As we just said, an area, and other multi-dimentional data), how can we make the searching more efficiently? That’s must be interesting, and you not need to be feel confuse for this because we have give you a method to resolve this problem : R-tree, and its change version,R* tree . In this article, I will introduce this amazing invention to you(We will pay more focus on R*tree). To describe and explain its structure, and after that I will use the programming language to implement it(I’m familiar with c++, so I will use this). I assume that you already have considerable programming knowledge. And I will make it easy to understand as much as possible. 2. R-treeI would like to create a new figure to express what’s the R-tree, so I want to use a picture of R-tree’s bounding box(It has a more serious name: minimum bounding rectangle, I guess.) and a tree structure’s figure to express the R-tree’s feature.In this picture, you can see the different Space division.So, we can express the tree’s structure as this one:We can learn more about the r-tree’s structure. Anytime when we have a new node insert in our tree, we should consider about which path can keep the tree’s bounding box’s area in a minimum value, then we will choose that place. Now, I will list its features: R-tree have two important value, we use m and M as trait of R-tree, each node（Except the root node） has child nodes from m to M. And the two values are depend on the situation.If a leaf node is not a root, it should have a amount of records from m to M. Each record belongs to a leaf node have a unified form, (ex:[I, tumple identifier]) the I is a minimum bounding box on the n-dimentional space. If a node isn’t a leaf node or a root node, it musts have a range of child nodes from m to M. A Not-Leaf node’s structure,[I, child-pointer], the I a minimum bounding box which can include all the bounding boxes of its child-pointer. If root node is not a leaf node, it must contain at least two nodes. All the leaf nodes are on the same layer. The max value of R-tree’s height is (|Log2 m^n| - 1), because each node has m nodes at least, and the biggest value of nodes is equal to |N/M|+|N/M^2|+….+1 , so if all the nodes of a R-tree have m child-pointers except root node, it’s achieve the worst situation that when we excute this program’s searching operation.If the tree’s structure meets all the requirements above, we can call this structure “R-tree”.This Structure is very important in Database’s application, when we want to find some exact spots in your country, or a more a bigger range(The earth?), your searching program would use lots of time………(Just imagine you wait for five minutes to find a restaurant you are hungry.) Now, we should Implement this tree sturcture by using the programming language(Matlab? Well, we can use matlab right? It’s a very convenient tool to do the experiment,but I want you to better understand this knowledge, I’d like to use C++.) If you don’t mind……, I will follow this structure to write the program. First, let’s look at its structure: 12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once //R Tree&apos;s definition#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std; //intervalclass RTInter&#123;public: float IMax; // lower bound float IMin; // upper bound&#125;;// Use RTRange to define the Range of a Node,// you can use it to describe high-dimensional rectangle.typedef vector &lt;RTInter&gt; RTRange;//Tree&apos;s Nodeclass RTNode&#123;public: int type; // Node&apos;s type RTNode * Parent; // Parent node RTRange Nrange; // Node&apos;s area int childNum; // children&apos;s number RTNode ** childSet; // child node pointer&#125;;typedef vector &lt;RTNode *&gt; RTNodeSet; //a set for all the Nodetypedef vector &lt;double &gt; RTPoint; //use to record multidimensional pointclass Tree&#123;public: int height; // The height of the tree int dim; // The dimention of the tree RTNode * Root; // Root of the tree int m; // The minimum number of nodes int M; // The maximum number of nodespublic: Tree(void); ~Tree(void);&#125;; Until now, we have given the R-tree’s defination, but we didn’t give the Rtree’s structure.Don’t worry, because that’s my decision. I will write the Rtree’s program, and when you understand the basic program, I will tell you the part of Rtree.But to be honest, That’s must be a long article…. When I start to write this, I haven’t to realize this situation….Just Joking. :) 3.AlgorithmOf course, the first operation is initialization, but I will start with a step that we all in common sence——– 3.1 Searching AlgorithmFirst, we will implement the searching algorithm, we use this to find the node in our searching area.purpose: Find the nodes we wantWhen I try to describe these algorithm, you can see some different function in our code, some easy function I don’t perpare to display because I can’t make this article so long. :)But I will give some interpretion.Now, we begin, and we assume that the T represents the Root node, and the input parameter is S(the rectangle， if your R-tree is a structure with n-dimentional data, that’s must be a region that difficult to imagine.) If node T is not a leaf node, do the Searching in its child trees, find a EI intersect with the region S, and change the T to proto node’s child node, until find a leaf node. If node T is a leaf node, get the TI(The T’s area.) and check if the EI’ region include the S. 12345678910111213141516RTNode * Searching(RTNode * S_node,RTRange rect)&#123; if(S_node-&gt;childSet == NULL)&#123; if (Check(S_node-&gt;Nrange, rect))&#123; return S_node; &#125; &#125; else&#123; for(int i = 0;i &lt; S_node-&gt;childNum - 1; i++) &#123; Searching(S_node -&gt;childSet[i], rect); &#125; return 0; &#125;;&#125; 3.2 Insert Algorithmpurpose: Insert a new index E in the R-Tree Call this function Choose Leaf to find a place P to insert the new item E If P have the room(L not have M nodes) we will insert the E to P, but if P is filled with nodes, then we would call the splitNode function and get p and pp which have the whole nodes include E and the original entry P. Call the funcition AdjustTree on L, if we have already split the L, we adjusted the LL, too. If the node split caused the division of root node, the program will create a new root node which have two exist nodes. 3.3 Choose Leaf AlgorithmThen, we should find a place to store our new node.We call the “Choose Leaf”. We called it “the Choose Leaf Algorithm”, it not only consider for the initialization, but also for the insert opreration.We use this algorithm to find a leaf node to insert a new node.Should we describe this algorithm by the natural language? Well, just for help you get more understand about this algorithm, it also can helpful to myself.purpose: Find a leaf node to place a new item E We set the root node is N. If N is a leaf node, the function will add the new node E to N. If N is not a leaf node, and the N has several pointers of index. We use F as a index in N, and if we want to add the E to the F’s child-pointer, we should expend the area of F to include the area of E(Of course we should keep the minimum area.), then we caculate the new area of F(We called it FI.), but we couldn’t to choose this ‘F’ by chosing randomly.We will do this operation for all the child-pointers of N. And we can get the minimum area, and find a benefit child node of N, we use the x to express it. And we do the loop operation from the ‘2’, until we find the ‘x’ is a leaf node. 12345678910111213141516int ChooseLeaf(RTNode N_node, RTNode * S_node)&#123; double Area_t = 0; //create for store the area if(S_node-&gt;childSet == NULL)&#123; *(S_node-&gt;childSet)[0] = N_node; //as a new child node of N_node &#125; else&#123; for(int i = 0; i &lt; S_node-&gt;childNum - 1 ;i++) &#123; //add the new node&apos;s region in a child node, and calculate the new value of range //Area_t = addArea(); //addnode(); &#125; &#125; return 0;&#125; 3.4 Adjust Tree Algorithmpurpose: Change the “L” node to become the root node, this function can adjust the R-tree’s structure. We use the N as a signal of L, and if L has already spilt, we will use the NN to represent the LL. If N is a root node, then we will stop this algorithm. We use P to represent N’s parent’s node, and EN is the N’s index in P’s child-pointer. Adjusting the ENI to include all the nodes of N. If N have already spilt, there must be a NN node in our sequence, if this happen, we will create a new node ENN(NN is it’s parent node, we can use “Let ENNP points to NN” to express), and of course, the ENN’s rectangle(ENNI) is enclosing to the all the rectangle of NNI. If P still has the enough space, add the ENN to the P’s child-set, or use the splitNode to create the P, PP, ENN, and all the nodes of P. Set N = P, if a split program cause the NN = PP, loop the step from the 2. step.To Be Continue……..I will see you in next article. :)","pubDate":"Tue, 01 Nov 2016 13:56:55 GMT","guid":"https://finalagito.github.io/2016/11/01/R-and-R-Tree-一-The-Dynamic-Structure-For-Spatial-Searching/","category":"algorithm"},{"title":"The Linar Regression: The First Step Of Machine Learning","link":"https://finalagito.github.io/2016/08/17/The-Linar-Regression-The-First-Step-Of-Machine-Learning/","description":"1. Why did I introduce regression algorithm in the first place?I glad to start write this article, and just as the title’s words, I want to use ‘Regression’ as the first step of the Machine Learning’s world. Some senior learner may have some suggest about this article, and I’m glad to see you feedback some information. Regrassion, This is a base course when you get into the field of Supervised Learning. Now I’ll introduce this knowledgepoint for you. And may be, I’ll do more introduce about Supervised Learning latter. 2. Linar RegressionI perpare to talk about Regression from the most simple one: The Linar Regression. You may be famillar with this name, that’s great. Because you have alreadly learned some basic knowledge of the Regression. This part of lecture is called least squares technique(Maybe? I can’t be too sure). You can see this topic in your primary school’s textbooks. Now, Let’s Start. (1) Single Variable Linear RegressionYou may have some questions: What’s the Regression problem? Well, the regression problem is that we had got the data in the past time and we use it to predict a continuous output like price. And now, I would give you an example to help you understand the algorithm. If you wants to predict the championship results of Meter race project in the next Olympic Game. So, What would you do? Ok, Now, I provide you the figure of the sports scores of recent years:Then, you can do the predict to the scores of meter race project in the next Olympic game. So, how I can do that? When you check the data in this figure, you can find some regulation, every 4 years there are a score to fit them. And you can use a algorithm to fit, then you can get the rules between in these data time.Perhaps, you can make a quation to describe this line:1f(x) = kX + b; but, it can’t be so simple like this, our data is confusion and disorder, we should to consider for the error, so, the true equation is:1Y[i] = f(x[i]) + E(x[i]); The i is the serial number of the Training data we got, and the Y is the output.we gave the definition of the f(x), and the E(x[i]) is the error of the x[i].Now, I have a equation. In this function,we have simple input and output, we put into the value of the year and get a output, just one feature(year), that’s why we called it ‘Single’.Now, we can assume that the model is a quadratic function: Then, let us see a more complicated one. You would follow with me, right? (2)Multivariate Linear RegressionI could use a example to tell you what’s call the multivariate linear regression, in fact, it’s a very common example.If I want to buy a house, I would do a predict to the house’s price, then, I can get the price that I may have to pay.Of course, you can still use the house’s area as an input and the house’s price to be an output, but if we do this, the question we will meet is that we can’t make a high accuracy of prediction.It’s not difficult to think, because there isn’t only a simple feature to influence the house’s price, so, we should take the other features into this model, then we will have several inputs and one output, this is a form of Multiple Linar Regression.If you don’t understand, don’t worry, I’ll use a diagram to explain this concept.So, this time I want to use another example to descripe the multivariate linear regression, may be you are similar with this event: If you want to by a house, you will find some factors to predict the house’s price, but only one feature can’t get a good accuracy, so you may need to use two, three or more features as the inputs value, so, that’s what I want to say. Now, I will give two figures, one is for Single value’s situation and another is for the Multiple’s. This picture comes from the Machine Learning course of Washington. If we compare this picture and the above one, we can see the diffience of the two situations.(Suppose we function has two inputs: the house’s age and the square feet)The Results no longer only decided by an element, but controlled by house’s age and square feet.As you know, We cannot be too severely limit your thinking, So you can expand your thinking: How the situation will be If we get a (n + 1) dimensional input?So we also can use a fuction to describle the relationship between the (n + 1) dimensional input and house price( In the above example, we only used a two-dimensional input, Here I will it to expand to if we have the ‘n + 1’ d): We assumed the X[0] = 1;If you have the knowledge of linear algebra, you can find that this quation equal to θ’X. (3)Gradient Descent AlgorithmNow, if we use the idea in upon part of this article, we have to set a part called “quality metric”(That’s right, look at the orange block in the picture). This module makes the program working.Our Predict of house price could be have error(In fact, there is error is certain), we need to have a method to let computer to make more accurate predictions by calculation accuracy.The method to resolve this question is that we called the Gradient Descent Algorithm. Aha, this gradicent algorithm is very important in the Machine Learning’s history.Ok, let us look about it. May be you have already find the key of the above equation, yes, the Gradient Descent Algorithm is a method to find the most suitable value for the θ[1…..n].(The value of n is definited by your features number)Now we have a question: How can we make a assess of the predict result?To diffierent situation have diffierent methods, but we just talk about one function for the Regression(Is this because of our title). Now, I used this equation to describe the deviation between the predicted and actual values: h(θ)(x[i])-y[i]And we will the n results together, this is the first assessment of the eqation(just for one feature).Remeber the 1/n has did a balance for the value.We got the function about the assessment, now how we define the value of the θ?Can I use this picture at this location and take a relaxed? We called this “Cost Function”.And the Alpha(α) in the equation is called the “learning rate”, I’ll introduce this on the below. So, this is the one feature’s situation, and you can imagine that there is multidimensional for θ[1…….n]. feature normalization - for Multivariate Linear Regressionfeature normalization is important，So we have to do some feature scaling, Let all the value of the change in the interval [- 1, 1].You should make sure feature’s value are on a similar scale, use different methods according to different situations, don’t asking me about this, maybe you could try xi=(xi-μi)/σi. Learning Rate and How Can It Stop?Will, that’s the most importance, and this is a problem that you want to know. How can it Stop and, when? Look this picture(Also from the Andred Ng’s class):We can see that, through the iteration step by step procedure, we arrived at the centre of the circle in the picture. That’s what I wanted.(To find the minmum of J(θ))But if the α is so big, then we can’t find the minmum of J(θ). Now, you have a intuitive impression of Learning Rate, and in some situation, you have to design a method to find it.Well, the worst and common method is try to verify every possible values. :) 3.SummaryNow, today we have done a macro for the “ Linar Regression”, but there are a special kind of species called “the Logistic Regression”.This belongs to the category of “classification”.I will continue this in a future article. :)","pubDate":"Wed, 17 Aug 2016 07:36:00 GMT","guid":"https://finalagito.github.io/2016/08/17/The-Linar-Regression-The-First-Step-Of-Machine-Learning/","category":"Machine Learning"},{"title":"The first Course Of Machine Learning","link":"https://finalagito.github.io/2016/08/05/The first Course Of Machine Learning/","description":"well, today we’ll talk something about Machine Learning.First, I have to say, I do not often use English to write article, if you can help me find some mistake in grammar, I’ll be very happy.So, let’s get into today’s business. 1.What’s the Machine Learning?This phrase has became more and more hot in recent years, but what is it?All right, these information about Machine Learning were come from Andrew Ng, I’m here to pay my homage to him.In 1959, Arthur Samuel,he defined machine learning as the field of study that gives computers the ability to learn without being explicitly programmed, this man wrote a checkers playing program.Arthur Samuel is not a very good checkers player, but he let the program to play 10’s of 1000’s of games against itself. And by watching what sorts of board positions tended to lead to wins and what sorts of board positions tended to lead to losses.Eventually, this computer play checkers better than himself.So,this is an old definition. A more recent definition was defined by Tom Mitchell:A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T as measured by p improves with Exprience E.well, that a long sentence, in fact,it’s just like a tongue twister.In the Checkers Game ,E is having the program played 1000’s Games against itself,T is the task of playing Checkers,and P, will be the probability that it wins the next game of checkers against new opponent. 2.Our Life With Machine LearningSo, we talk about so many things about what is Machine Learning, may be you still not have any interest in this field.Don’t Worry, I’ll say some information more Close to our life:This technology is looks so useful, but where can we use it? Please calm down, I’ll be list in the following: intercept Spam message and E-mail.That’s so useful ,thanks for it. To classify the customers needs and preferences.Which kind of music would you like? Search engine just like geogle and baidu.You want a better Search engine?Well,Machine Learning is important. Robots made a decision. Like AlphaGo? perhaps. etc. In fact, I’m very excecting when I write this article. why?“It’s must be the most important Century in humans history.” by SUNIL RAY.There may be some exaggerated but most are correct.The democratization of the tools and techniques will take the development to the technology.In the future, everyone will be Contributing to the future of humanity. 3.Machine LearningBroadly, there are 3 types of Machine Learning Algorithms: Supervised Learning Unsupervised Learning Reinforcement LearningAnd I will introduce each module muinutely. (1) Supervised LearningSupervised Learning,this must be the first type of Machine Learning Algorithms you met.This algorithm consist of a target / outcome variable (or dependent variable) which is to be predicted from a given set of predictors (independent variables).Using these set of variables, we generate a function that map inputs to desired outputs. The training process continues until the model achieves a desired level of accuracy on the training data.Here are some famous algorithms are belongs to Supervised Learning: Regression ( OK.I will introduce this later ) KNN algorithms ( the easiest one ) Decision Tree ( if you only have a little data ,It’s may be easy to Overfitting,but to be honest,it’s a classic algorithm ) Random Forest ( based on the decision tree ) Logistic Regression ( different from Regression,this is a classification not a regression algorithm) SVM( The support vector machines ) ( a important algorithm ,you must know it )etc.(2) Unsupervised LearningI’d like to introduce this kind of Machine algorithm after the Supervised Learning.The Unsupervised Learning do not have any target or outcome variable to predict or estimate,it is used for clustering population in different groups.When you face to the large Scale data,you can consider to use the Unsupervised Learning.Here are some famous algorithms are belongs to Unsupervised Learning: k-means ( want to do a classification about your customer? this one is the Basic algorithm ) Mini Batch K-Means ( k-means can’t deal with the big data,it will take you a lot of time to compute.In this situation you can use this algorithm ) Neural network models ( A famous One ,right? You must know about this model—perpare for the course of Deep Learning ) Gaussian Mixture Model ( GMM )( If you want to do a speaker recognition,the methods of MFCC + GMM will be a good choice ) Dimensionality Reduction Algorithms ( high-dimensional? No ,you can’t design a algorithm base on this situation,So—you need this One )etc. (3)Reinforcement LearningUsing this algorithm, the machine is trained to make a specific decisions. It works On this way: the machine is exposed to an environment where it trains itself continually using trial and error.if you want to make a very smart Chinese chess program, the Supervised Learning and Unsupervised Learning will spend a lots of time on Traversal calculation. So, the better method is use Reinforcement Learning.Here are some famous algorithms are belongs to Reinforcement Learning: Markov Decision Process,(MDP) Monte Carlo Methods(an important value compute algrorithm)I didn’t use so much about Reinforcement Learning, So I’ll talk in the later published articles.4.SummaryWell, today we have a general overview of the Machine Learning, after this article, I’ll published more articles about the algorithms and new Technology of Machine Learning, maybe you can see something else. you may feel difficult to read this article because it’s my first time to use English write a long article as this One.Well, it’s not a problem, for me this is a new beginning,and maybe it’s same to you.","pubDate":"Fri, 05 Aug 2016 00:06:16 GMT","guid":"https://finalagito.github.io/2016/08/05/The first Course Of Machine Learning/","category":"Machine Learning"},{"title":"Hello World","link":"https://finalagito.github.io/2016/07/31/hello-world/","description":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","pubDate":"Sun, 31 Jul 2016 15:20:08 GMT","guid":"https://finalagito.github.io/2016/07/31/hello-world/","category":""},{"title":"C++设计模式（二）：单例模式","link":"https://finalagito.github.io/2016/07/31/C-设计模式（二）：单例模式/","description":"一.什么是单例模式？ 这次我们介绍的是单例模式，也是创建型模式的一种，这应该是最为简单的一种，那么，什么是单例模式呢？所谓的单例模式，是我们在运行程序的时候，有些实例，在程序中只要存在一个就足够了，如果我们每次进行某项操作都会创建一个实例，则这会对计算机的资源和空间造成较大的浪费，这是我们不愿意看到的。 就比如我们之前所说的工厂模式，我们当然希望系统当中只存在、也只可以存在一个工厂，如果我们在每调用一个功能的时候就创建一个工厂，就会对计算机的资源造成极大的浪费，我们无法对工厂实例进行有效的操作（如果需要的话）。 而单例模式，就是用来保证我们所需要的对象在程序运行中只存在1个而存在的（其实你可以用添加一个计数属性的方法让它能够实例化为有限个，但是实际上我们一般并不需要这样的办法）。 其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点（你也许可以称它为接口），该实例被所有程序模块共享。 二.单例模式 就像我们前面所说，单例模式，是为了保证我们所需要的对象在程序运行中只存在1个。那么它究竟做了什么操作？ 实际上，单例模式的步骤非常简单。 单例模式的主要操作就是将一个类实例化之前，首先对当前程序进行确认，看现在的程序当中是否已经存在了一个实例化的对象，如果存在，则我们直接将这个对象的引用或者指针返回，即获取到当前存在的这个对象，反之，则创建这个对象，从而保证该种类的对象在程序中只存在一个。也许我应该先上段代码？123456789101112131415161718192021222324//这是我们所要求全局只能存在一个的类class CSingleton&#123;private: CSingleton()&#123;&#125;; static CSingleton *m_pInstance;//静态指针public: virtual ~CSingleton()&#123;&#125;; static CSingleton* GetInstance() &#123; if(m_pInstance == NULL)//判断对象是否存在 m_pInstance = new CSingleton(); return m_pInstance; &#125;&#125;;************调用**************CSingleton* CSingleton::m_pInstance = NULL;int _tmain(int argc, _TCHAR* argv[])&#123; CSingleton *p1 = CSingleton::GetInstance(); CSingleton *p2 = p1-&gt;GetInstance(); return 0;&#125; 如你所想，不难，确实可以称的上是最容易的设计模式了，而我将它作为第二个设计模式来讲，除了它简单以外，其实还有一个原因，就是它经常和工厂模式结合使用那么你也猜到我下面要做一些扩展了对不？没错，那就是—— 三.结合了单例模式的简单工厂模式 实际上我们还有另外一个例子可以使用这个单例的概念，比如我们点击一次按钮，创建一个窗口，那么如果我再按一次，如果并非单例模式，那么我每按一次都会产生一个窗口，到最后想像一下满屏窗口的场景……嗯，还是单例模式好。 那么我们来看一看他们的UML图（请原谅我用上次的例子炒现成的）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//运算类class Operation&#123;private: double A;//第一个数 double B;//第二个数public: Operation()&#123;&#125;; virtual ~Operation()&#123;&#125;; bool SetA(double a)//设定A &#123; this-&gt;A = a; return true; &#125;; bool SetB(double b)//设定B&#123; this-&gt;B = b; return true; &#125;; double GetA()//获得A &#123; return this-&gt;A; &#125;; double GetB()//获得B &#123; return this-&gt;B; &#125;; virtual double GetResult() = 0; &#125;;//相加类，在此处我们继承了运算类class Sub :public Operation&#123;public: Sub()&#123;&#125;; virtual ~Sub()&#123;&#125;; double GetResult() &#123; return GetA() + GetB(); &#125;;&#125;;//相减类，同样继承了运算类class Dec :public Operation&#123;public: Dec()&#123;&#125;; virtual ~Dec()&#123;&#125;; double GetResult() &#123; return GetA() - GetB(); &#125;;&#125;;//工厂类，在此我们不用其他更复杂的工厂形式了，直接用简单的class Factory&#123;private://注意这里是一个关键点，我们将构造函数归为private一类，让从外部无法单独实例化它，而必须通过下面的Create函数 Factory()&#123;&#125;; static Factory* Factory_Instance;public://没错就是它 static Factory * Create() &#123; if (Factory_Instance == NULL) Factory_Instance = new Factory(); return Factory_Instance; &#125; Operation *CreateProject(string type) &#123; if (type==&quot;Sub&quot;) return new Sub(); if (type == &quot;Dec&quot;) return new Dec(); return NULL; &#125;;&#125;;**************主函数调用*****************//静态指针要在此处实例化 Factory* FactoryChild :: Factory_Instance = NULL;int _tmain(int argc, _TCHAR* argv[])&#123; Factory* Test = Factory :: Create(); Operation *p1 = Test-&gt;CreateProject(&quot;Sub&quot;); p1-&gt;SetA(4); p1-&gt;SetB(8); cout&lt;&lt;p1-&gt;GetResult()&lt;&lt;endl; Factory* Test2 = Factory :: Create(); Operation *p2 = Test-&gt;CreateProject(&quot;Dec&quot;); cout &lt;&lt; p2-&gt;GetResult();//结果为12&#125; 四.注意点 1,构造函数不能被继承，单例模式中必须将构造函数设置为私有，将析构函数设置为公有虚函数 2,可以在单例模式中再调用单例，通过对象引用和对象指针实现虚函数的多态，公有继承基类有的虚函数，派生类的成员函数不使用virtual也是虚函数，但是函数内部具体调用的函数又是另外一个概念了，良好的做法就是在派生类中也使用关键字virtual 五.单例模式的优缺点优点：1.减少了时间和空间的开销（new实例的开销）。2.提高了封装性，使得外部不易改动实例。缺点：1.由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。2.单例类的职责过重，在一定程度上违背了“单一职责原则”。3.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。以上的缺点都是一些滥用单例模式带来的错误，但是说实在的，你总有要用到它的时候，不过要谨慎使用就是了（笑）。","pubDate":"Sun, 31 Jul 2016 03:19:49 GMT","guid":"https://finalagito.github.io/2016/07/31/C-设计模式（二）：单例模式/","category":"C++设计模式"},{"title":"C++设计模式（一）：工厂模式","link":"https://finalagito.github.io/2016/05/21/C-设计模式（一）：工厂模式/","description":"一.什么是设计模式？ 如果要想完全的理解什么是设计模式，我们就需要对设计模式本身有一定的了解，那么，什么是设计模式呢？我们在进行一般的C++代码编程的时候，经常听到说，C++是一门面向对象的语言，要使用面向对象的方法，但是我们在实际操作的时候总会感到迷惑：面向对象究竟是什么样的？怎样才是有别于“结构化编程”的编程方法？ 那么，这个时候就轮到我们的主角设计模式登场了。 所谓的设计模式，是一种代码经验的总结，它在编程中反复使用，保证代码的可靠性和可维护性。它让开发者能够更加好的复用成功的结构体系，也方便后面的开发者理解设计思路。 现阶段，设计模式主要分为三个种类：创建性模式、结构型模式和行为型模式。 今天我们要说的工厂模式，就是创建型模式的一种，也是开篇必讲的一种。 二.简单工厂模式要想讲述工厂模式，我们一般都会从简单工厂模式开始讲起。如果你要是被拜托制作一款系统应用于上班族的“刷脸”上班，你会怎么做？ 啊，我看看，嗯….如果按照我们之前的想法，刷脸做一个类，然后把人脸识别、人脸特征提取、人脸相似度比对全都放进去，之后数据库上传和查询做一个类，然后让总体界面调用，但是如果过了一段时间，公司觉得刷脸还不够，因为有些家伙很狡猾，采取了一些手段蒙混过去了这个部分，所以公司觉得要在之前脸部注册的数据上在做些新功能。这个时候你怎么办呢？想必你肯定需要进入到刷脸的这个类里面去修改里面的方法和添加新的函数，这样一来就十分麻烦，代码的可维护性就相当的差。或者像《大话设计模式》中所说，设计一个计算器，如果你将所有的加、减、乘、除都放在一个类里面，则在开发新功能的时候公司就不得不向你开放全部源码，这就是设计上的错误。 这个时候，工厂模式就发挥了作用。 工厂模式在开发系统的扩展功能方面颇有优势，而且可以轻松方便的构造对象实例，不用担心构造对方实例的复杂过程。 特点：提供创建对象的接口. 为系统结构提供了非常灵活强大的动态扩展机制，只要我们更换一下具体的工厂方法，系统其他地方无需一点变换，就有可能将系统功能进行改头换面的变化 而简单工厂模式，可以说是工厂模式的简化版本，下面我们通过一个案例来详细的分析一下： 我们还是使用之前说的计算器的案例吧，这个案例简单而且比较省事（所以关键是比较省事么….(笑)）首先我们给出简单工厂模式的UML图：如图所示，我们在图中总共有4个类，分别是工厂类Factory,还有计算类的父类Operation,继承它的子类sub和Dec(我就不把加减乘除全写上了，大家知道就行。)也就是说，用户不需要直接对计算类进行操作，用户只需要实例化一个工厂类的对象，然后调用工厂类中的CreateObject方法，就可以创建一个Operation的子类对象（当然，CreateObject()中的String参数是用来判断到底实例化的是哪一种子类对象，比如我设定当传参数“Sub”时，就创建一个Sub类的对象）举例如下：12345678Operation *CreateProject(string type) &#123; if (type==&quot;Sub&quot;) return new Sub(); if (type == &quot;Dec&quot;) return new Dec(); return NULL; &#125;; 这样就会返回一个Opration 的子类对象，函数中的new 调用的是对应子类对象的构造函数。之后只需这样调用，就能够得到结果：12345Factory* Test = FactoryChild::Create(); Operation *p1 = Test-&gt;CreateProject(&quot;Sub&quot;); p1-&gt;SetA(4); p1-&gt;SetB(8); cout&lt;&lt;p1-&gt;GetResult()&lt;&lt; endl; 此时我们可以得到输出，是12 这就是最简单的简单工厂模式，相信大家已经感受到他的好处，因为我们在开始开发扩展程序的时候，可以不在对原先已经成功的模块进行修改，这一编程方式符合C++编程中的依赖倒转原则 三.工厂模式 说完了简单的，我们来看看更进一步的。工厂模式，其实，工厂模式只是在简单工厂模式的基础上修改一些东西，你可能会问，为什么还要修改呢？刚刚的工厂模式看起来已经非常方便、还有什么必要再修改呢？是的，简单工厂模式使我们在开发计算器的扩展程序的时候可以不用面对全部的、复杂的源码，而是直接开发集成到计算器的基类就可以了，但是，在这个时候，我们仍不能满足，因为我们发现，它违背了C++编程中的开闭原则（所谓的“开放-封闭”原则就是开放接口，封闭修改）。即使是我们可以不用修改Operation类，我们却需要对Factory进行编辑，这仍然是一个不好的地方。为了让工厂类也能够脱离这不舒服的修改模式，我们的工厂模式，闪亮登场了。下面，我们照例贴出工厂模式的UML图，通过两张UML图的对比，我们可以清晰的看出两者的区别：没错….看出区别了吗？其实我们就是对工厂类做了和Operate类一样的事情，我们将Factory类也抽象成了一个基类，当我们想要做什么的时候，我们就直接生成对应的工厂子类（比如SubFactory）,然后调用方法CreateProject()就会直接生成对应的Operation的子类（Sub）。但是它还是有缺点。缺点：增加运算类，会修改客户端代码，工厂方法只是把简单工厂的内部逻辑判断移到了客户端进行，每增加一个功能的类，就需要增加一个功能工厂，增加了额外的开发量。下面，我们来说说最后一种： 四.抽象工厂模式工厂模式总算是看起来像个样子了，但是还不够，老看计算器的问题有点腻了，我们来看看大人的生意吧！我们来生产电脑配件吧！但是我产出的电脑主机箱中的零件不只一种，要怎么办？再来一个工厂？不不不，你何必要浪费那个钱呢？我们要把现有的工厂利用起来:希望你没被这张图晃花眼睛，实际上，我们确实是做到了将多个产品放到了一个工厂下面，这样的话你就可以生产出两个牌子的主板和Cpu了，我们在抽象工厂类中生成产品的时候，我们生成工厂子类并调用相应的产品方法，非常灵活。我们能够在两个牌子中间进行切换，但是说实在的，修改客户端代码这部分还是逃不掉。优点：易于切换，方便管理缺点：还是需要修改客户端代码 五.附加内容《大话设计模式》中对于这个部分有利用简单工厂模式进行一个改进：嘛，其实就是把之前的模式又用了回来而已。那么我们现在总结一下：简单工厂模式：只有一个工厂类，且使用了判断语句。违背开闭原则，较简单工厂方法模式：只有一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。 区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。简单工厂模式是工厂模式打破开闭原则的缩减版。","pubDate":"Sat, 21 May 2016 09:35:16 GMT","guid":"https://finalagito.github.io/2016/05/21/C-设计模式（一）：工厂模式/","category":"C++设计模式"}]}